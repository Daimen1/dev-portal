I"39<p>To fulfill a request from a client to a service, a snet-daemon needs to store and process information about the service payment. This connection is called the payment channel.</p>

<p>If there is only one service and corresponding snet-daemon the process is easy:</p>

<p><img src="/assets/img/mpe/payment_channel_storage_single_replica.jpg" alt="one replica" /></p>

<p>When payment passes a validation process, the payment channel is stored in an internal storage
to be claimed when the service successfully accomplishes the request.</p>

<p>The situation becomes more complicated if a service provides several replicas. In this case it is not possible to have several separated snet-daemons each of which has an independent internal storage.</p>

<p><img src="/assets/img/mpe/payment_channel_storage_several_replicas_several_independent_storages.jpg" alt="several replicas with several independent storages" /></p>

<p>One drawback of using a separated payment channel for each replica, is that it can be expensive from the gas consumption and time execution point of view, because each operation to open a channel requires it to be processed by the blockchain.</p>

<p>The other one is that such model is subject to an attack where the same payment can be used for services
from different replicas. This leads to a model where all snet-daemons for the same service should use the shared storage.</p>

<p><img src="/assets/img/mpe/payment_channel_storage_several_replicas_one_storage.jpg" alt="several replicas with several independent storages" /></p>

<p>However, if only one instance of a storage is provided it can easily become a single point of failure
for the whole system. When it fails, this leads to failure of all payments even when there are live replicas.</p>

<p>Therefore, we are using distributed storage. There is plenty of available storage, and we just need to make the optimal choice. We are adhering to several criteria:</p>

<p>According to <a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a>, we only have a choice to select two out of three main guarantees:</p>
<ul>
  <li>Partition tolerance</li>
  <li>Availability</li>
  <li>Consistency</li>
</ul>

<p>We need a partition tolerance distributed storage to save system from network failures. Furthermore, we also need storage that provides strong consistency guarantees to avoid a situation where the same payment is used twice on different replicas.</p>

<p>This does not mean that the availability guarantee is not important. This means that if all but a few nodes of the distributed storage are still available, it will not be possible to read/write requests. This is a price we are paying in exchange for a strong consistency storage system.</p>

<p>Lets strike out the availability guarantee and leave only partition tolerance and consistency:</p>

<ul>
  <li>Partition tolerance</li>
  <li><del>Availability</del></li>
  <li>Consistency</li>
</ul>

<p>The new design now looks like this:</p>

<p><img src="/assets/img/mpe/payment_channel_storage_several_replicas_separate_distributed_storage.jpg" alt="several replicas with several independent storages" /></p>

<p>The current approach is fine, but it requires for a service owner not only to setup a snet-daemon for each replica, but also to deploy a separated distributed storage. This can be a rather tedious and complicated task.</p>

<p>To avoid this, it would be good to incorporate the distributed storage nodes into snet-daemons so it would be the snet-daemon’s task to run required distributed storage nodes:</p>

<p><img src="/assets/img/mpe/payment_channel_storage_several_replicas_embedded_distributed_storage.jpg" alt="several replicas with several independent storages" /></p>

<h2 id="considered-storages">Considered storages</h2>
<p>We are looking for a distributed storage with strong consistency guarantees which can be run by snet-daemon (e.g. be easily integrated into a Go program).</p>

<p>Some of the storages that were considered are:</p>

<table>
  <thead>
    <tr>
      <th>Distributed Storage</th>
      <th>Language</th>
      <th>Consensus</th>
      <th>Embedded Server Support</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://github.com/etcd-io/etcd">Etcd</a></td>
      <td>Go</td>
      <td>Raft</td>
      <td><a href="https://godoc.org/github.com/coreos/etcd/embed">native</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/hashicorp/consul">Consul</a></td>
      <td>Go</td>
      <td>Raft</td>
      <td><a href="https://github.com/hashicorp/consul/issues/467">ticket 467</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/apache/zookeeper">ZooKeeper</a></td>
      <td>Java</td>
      <td>ZAB</td>
      <td><a href="https://zookeeper.apache.org/doc/r3.4.6/api/org/apache/zookeeper/server/ZooKeeperServerMain.html">native</a></td>
    </tr>
  </tbody>
</table>

<p>Etcd was chosen because it is written in Go, and has out of the box embedded server support. This means that its nodes can be started and stopped by snet-daemon replicas.</p>

<p>It is not clear whether it is possible to run a consul server agent from a Go application.
A few examples (embedded-consul
<a href="https://github.com/golovnin/embedded-consul">1</a>
<a href="https://github.com/pszymczyk/embedded-consul">2</a>
just bundles the Consul as a binary package.</p>

<p>Zookeeper is just written in Java and it requires to have an additional support to start Zookeeper nodes from Go.</p>

<p><strong>Note</strong>: all these storages use a quorum to get a consensus during leader election and values writings.
This means that if the number of failed nodes are more than half of all nodes, then the the cluster stops working. As it was described before, this is a cost for a distributed system to provide strong consistency guarantees.</p>

<h2 id="etcd-storage">Etcd storage</h2>

<h3 id="running-and-accessing-embedded-etcd-cluster">Running and accessing embedded etcd cluster</h3>

<p>Starting an etcd node requires at least the following parameters:</p>

<ul>
  <li><strong>name</strong>: human-readable name for the node.</li>
  <li><strong>listen-client-urls</strong>: list of URLs to listen on for client traffic</li>
  <li><strong>listen-peer-urls</strong>: list of URLs to listen on for peer traffic</li>
  <li><strong>initial-cluster</strong>: initial cluster configuration for bootstrapping, for example:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name1=http://AAA.BBB.1.1:2380,name2=http://AAA.BBB.1.2:2380
</code></pre></div>    </div>
  </li>
  <li><strong>initial-cluster-token</strong>: initial cluster token for the etcd cluster during bootstrap</li>
</ul>

<p>The following Go code is used to start etcd node and use etcd client:</p>
<ul>
  <li><a href="/src/etcddb/etcd_storage_server.go">etcd_storage_server.go</a></li>
  <li><a href="/src/etcddb/etcd_storage_client.go">etcd_storage_client.go</a></li>
</ul>

<p>There are some <a href="/src/etcddb">throughput tests</a> which run several etcd nodes locally and measure number of writes, and compare and set requests per seconds.</p>

<p>Note: because all etcd nodes were run locally, the results can be different from when each etcd node is ran on its own separated server.</p>

<h3 id="etcd-cluster-size">etcd cluster size</h3>

<p>According to the <a href="https://coreos.com/etcd/docs/latest/faq.html">etcd FAQ</a> it is suggested to have
an odd number of etcd nodes in a cluster, usually 3 or 5. It also mentions that “<em>Although larger clusters provide better fault tolerance, the write performance suffers because data must be replicated across more machines.</em>”</p>

<h2 id="proposed-solutions">Proposed solutions</h2>

<p><img src="/assets/img/mpe/payment_channel_storage_several_replicas_embedded_etcd_cluster.jpg" alt="several replicas with several independent storages" /></p>

<p>The following solutions are based on the embedded etcd storage discussed in details in chapters below:</p>
<ul>
  <li>Command line etcd cluster creation</li>
  <li>Fixed size etcd cluster</li>
  <li>Incremental etcd cluster creation</li>
</ul>

<h3 id="command-line-etcd-cluster-creation">Command line etcd cluster creation</h3>

<p>This approach is to add a command line option to snet-cli which allows us to start an etcd instance
as part of etcd cluster:</p>

<blockquote>
  <p>snet storage init –name name –token unique-token –client-url http://AAA.BBB.1.1:2379 –peer-url http://AAA.BBB.1.1:2380 –initial-cluster name1=http://AAA.BBB.1.1:2380,name2=http://AAA.BBB.1.2:2380</p>
</blockquote>

<p>The list of client-urls then needs to be passed to each replica to have access to the etcd cluster storage.</p>

<h3 id="fixed-size-etcd-cluster">Fixed size etcd cluster</h3>

<p>This approach assumes that etcd nodes are started by replicas and that the size of etcd cluster is fixed. The initial configuration file contains a list of all replicas and information whether it should start etcd node or not:</p>

<p>For example:</p>

<table>
  <thead>
    <tr>
      <th>replica id</th>
      <th>start etcd node</th>
      <th>etcd node name</th>
      <th>etcd node client url</th>
      <th>etcd node peer url</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>replica 1</td>
      <td>yes</td>
      <td>node1</td>
      <td>http://AAA.BBB.1.1:2379</td>
      <td>http://AAA.BBB.1.1:2380</td>
    </tr>
    <tr>
      <td>replica 2</td>
      <td>yes</td>
      <td>node2</td>
      <td>http://AAA.BBB.1.2:2379</td>
      <td>http://AAA.BBB.1.2:2380</td>
    </tr>
    <tr>
      <td>replica 3</td>
      <td>no</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>replica 4</td>
      <td>yes</td>
      <td>node3</td>
      <td>http://AAA.BBB.1.4:2379</td>
      <td>http://AAA.BBB.1.4:2380</td>
    </tr>
    <tr>
      <td>replica 5</td>
      <td>no</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Such a configuration requires that all replicas which maintain an etcd node need to be started first
to have a functional etcd cluster.</p>

<h3 id="incremental-etcd-cluster-creation-approach">Incremental etcd cluster creation approach</h3>

<p>Starting etcd cluster requires that initial size of the cluster was defined during cluster bootstrap.
It means that the cluster begins to work only when quorum number of nodes join the cluster.</p>

<p>Suppose there are 3 replicas and they want to run 3 ectd nodes. When the first replica starts an etcd node, it is not able to write and read from the etcd because 2 more etcd nodes need to join the cluster.</p>

<p>As an alternative, it is suggested that the first replica starts with etcd cluster which consists of only one etcd node. In this case it will be able to read and write to the etcd. When the second replica starts it can find the existing etcd cluster (using the address of the first replica) and just adds the second node to the cluster.</p>

<p>This allows us to have a working etcd cluster even when only some of the replicas are running.</p>

<p>Note: etcd has a <a href="https://coreos.com/etcd/docs/latest/v2/discovery_protocol.html">Discovery Service Protocol</a>. It is only used in the cluster bootstrap phase, and cannot be used for runtime reconfiguration.</p>

<p>The following algorithm describes the creating and updating of the etcd cluster during replica initialization based on an incremental approach.</p>

<h4 id="input">Input</h4>
<p>Each replica needs to have access to the following info which is provided during the replica starting:</p>
<ul>
  <li>etcd cluster token value</li>
  <li>list of all replicas with corresponding values:
    <ul>
      <li>replica id</li>
      <li>etcd node name</li>
      <li>etcd ip address</li>
      <li>ectd client and peer ports</li>
    </ul>
  </li>
</ul>

<h4 id="cluster-configuration-table">Cluster Configuration Table</h4>
<p>The table with the given columns will be maintained in etcd cluster:</p>
<ul>
  <li>replica id</li>
  <li>timestamp</li>
  <li>running etcd server node flag</li>
</ul>

<p>The last field indicates that a replica started an etcd server instance and that it had been alive at the time when the record to the Cluster Configuration Table was written.</p>

<h4 id="replicas-to-etcd-nodes-correspondence">Replicas to etcd nodes correspondence</h4>
<p>Each replica can use a predefined function which returns the number of etcd nodes that are necessary to run for the given number of live replicas.</p>

<p>The function can be described in pseudocode like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>numberOfEtcdNodes(numberOfReplicas) {
    1, 2   -&gt; 1
    3, 4   -&gt; 3
    5, ... -&gt; 5
}
</code></pre></div></div>

<h4 id="detecting-added-and-failed-replicas">Detecting added and failed replicas</h4>
<p>It is suggested to use the heartbeat mechanism to detect failures in replicas. Each replica needs to repeatedly write a timestamp using the replica id as a key to the <strong>Cluster Configuration Table</strong>. When the difference between the current time and the timestamp of the replica is higher than a certain threshold, the replica is considered dead.</p>

<h4 id="detecting-failed-etcd-nodes">Detecting failed etcd nodes</h4>
<p>etcd <a href="https://coreos.com/etcd/docs/latest/v2/other_apis.html#checking-health-of-an-etcd-member-node">Admin API Documentation</a> provides a REST api to check the health of an etcd node.</p>

<h4 id="initial-state">Initial state</h4>
<p>The first initialized replica detects that there is no etcd cluster and starts an embedded etcd instance.</p>

<h4 id="main-loop">Main loop</h4>
<p>Each replica reads the <strong>Cluster Configuration Table</strong>, checks the number of live replicas and calculates the number of required etcd nodes using the <em>numberOfEtcdNodes(numberOfReplicas)</em> function.</p>

<p>If the number of required etcd nodes is less than the current number of live etcd nodes, then only one replica with the lowest id that does not have a running embedded etcd node starts it and adds this node to the current cluster.</p>

<p>There can be two results:</p>
<ul>
  <li>The embedded etcd is successfully run</li>
  <li>The replica which starts the etcd misses the timeout and is considered dead</li>
</ul>

<p>If the etcd node initialization succeeds, the replica adds the record to the <strong>Cluster Configuration Table</strong> to let it know that it has running ectd node.</p>

<p>In both cases the process can be just repeated as is.</p>
:ET