I"•U<h2 id="introduction">Introduction</h2>
<p>The Multi-Party Escrow smart contract (‚ÄúMPE‚Äù), coupled with our atomic unidirectional
payment channels, enables scalable payments in the platform by minimizing the number of
on-blockchain transactions needed between clients and AI service owners. The MPE contract has
two main functionalities:</p>
<ol>
  <li>A very simple wallet with a deposit and withdraw function. Everybody can deposit AGI tokens into a Multi-Party Escrow, and everybody can withdraw their AGI tokens (which have not been escrowed at the moment).</li>
  <li>The set of the simple (‚Äúatomic‚Äù) unidirectional payment channels between clients and service providers and functions for manipulation of these channels.</li>
</ol>

<h2 id="atomic-unidirectional-payment-channel">Atomic unidirectional payment channel</h2>
<blockquote>
  <p>You can skip this section if you are familiar with the concept of payment channels.</p>
</blockquote>

<p>The main logical building block of the Multi-Party Escrow is a simple (‚Äúatomic‚Äù) unidirectional payment channel. You can find the implementation of the escrow contract for such a channel in the <a href="https://github.com/astroseger/escrow_contracts/blob/master/contracts/SimpleEscrow.sol">SimpleEscrow.sol file here</a>. A <a href="http://super3.org/introduction-to-micropayment-channels/">payment channel</a> is a tool that enables off-chain transactions between parties without the delay imposed by blockchain block formation times and without compromising the transactional security. There are several kinds of payment channels. Let us consider the simple unidirectional payment channel, the main logic is as follows:</p>

<ul>
  <li>The sender creates an escrow contract with a given expiration date and she/he funds it with
a desired amount of tokens.</li>
  <li>Each time the sender needs to send a small amount of tokens to the recipient she/he sends (to the recipient) the signed authorization to close the channel and withdraws from the channel the total amount of the tokens that are due.</li>
  <li>The recipient must check that the authorization is correctly signed and that the amount is correct, and that this amount is not exceeding the funds being escrowed.</li>
  <li>The recipient can close the channel at any moment by presenting a signed amount from the sender.  Of course it is better for the recipient to close the channel with the last authorization (with highest amount). The recipient will be sent that amount, and the remainder will go back to the sender.</li>
  <li>The sender can close the channel after the expiration date and take all funds back.</li>
  <li>The sender can extend the expiration date and add funds to the contract at any moment in time.</li>
</ul>

<p>In the model above, there is no way for the receiver to withdraw funds without closing the channel.
Otherwise, he could use the sender‚Äôs signed authorization a second time and withdraw 5 more AGI
tokens.
Therefore, we added a feature that allows the receiver to withdraw funds from the channel without
closing it, while preventing this replay attack. We used a simple, textbook solution: a nonce. We
add a nonce to the message that the sender signs, and this nonce changes each time the recipient
claims the channel.
With this improvement, payment channels inside MPE have the following favorable
properties:</p>
<ul>
  <li>The channel between sender and recipient can persist indefinitely. The sender can extend
the expiration time and add funds to the channel. The recipient can claim the amount
signed over to him at any time.</li>
  <li>The system is comfortably functional even when the Ethereum network is overloaded
with confirmation time of several hours or even more, for the following reasons:
    <ul>
      <li>Neither the sender nor recipient needs any confirmation from the blockchain. Alice can continue to add funds, and Bob can continue to claim them in the channel, with no confirmation from the blockchain. For example, after Bob claims his funds, he can inform Alice that the nonce of the channel has changed, and she can start to send messages with the new nonce. It is easy to demonstrate that this is safe for both the sender and the recipient. There is only one condition: the recipient should make sure that the transaction is mined before the expiry time of the channel.</li>
      <li>There is no race condition between claiming (from the recipient side) and extending/adding funds (from the sender side). The parties can use these functions at any time, and the final result will not depend on the order in which these transactions are mined.
When a user wants to call a given service, they must open a channel, add funds to it, and set an
expiry date that allows sufficient time for the service to fulfill its function. Each channel is
unique to a combination of client identity (sender), service identity (recipient), and daemon
group identity. This allows daemons in the same group to share payment information via etdc,
reducing the overall number of channels and simplifying life on the client side. Clients can be
end users interacting with the platform via the <a href="https://beta.singularitynet.io/">Marketplace DApp</a> or applications making calls
directly or through the SDK‚Äôs generated code.</li>
    </ul>
  </li>
</ul>

<h2 id="the-set-of-channels-and-manipulation-functions">The Set of Channels and Manipulation Functions</h2>
<h3 id="payment-channel-structure">Payment Channel Structure</h3>

<p>Each ‚Äúatomic‚Äù payment channel in MPE is represented by the following structure</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       //the full ID of "atomic" payment channel = "[this, channel_id, nonce]"
    struct PaymentChannel {
        address sender;      // The account sending payments.
        address recipient;   // The account receiving the payments.
        bytes32 groupId;     // id of group of replicas who share the same payment channel
                             // You should generate groupId randomly in order to prevent
                             // two PaymentChannel with the same [recipient, groupId]
        uint256 value;       // Total amount of tokens deposited to the channel.
        uint256 nonce;       // "nonce" of the channel (by changing nonce we effectivly close the old channel ([this, channelId, oldNonce])
                             //  and open the new channel [this, channelId, newNonce])
                             //!!! nonce also prevents race conditon between channelClaim and channelExtendAndAddFunds
        uint256 expiration;  // Timeout (in block numbers) in case the recipient never closes.
                             // if block.number &gt; expiration then sender can call channelClaimTimeout
        address signer;     // signer on behalf of sender
   }

mapping (uint256 =&gt; PaymentChannel) public channels;

</code></pre></div></div>

<p>Comments are self-explanatory, but few clarifications migth be useful.</p>

<ul>
  <li>The full ID of an ‚Äúatomic‚Äù payment channel is <code class="highlighter-rouge">[MPEContractAddress, channelId, nonce]</code>.</li>
  <li>The <code class="highlighter-rouge">MPEContractAdress</code> is the address of Multi-Party Escrow contract, which is needed to prevent a multi contract attack.</li>
  <li><code class="highlighter-rouge">channelId</code> is an index in the channels mapping.</li>
  <li><code class="highlighter-rouge">nonce</code> is a part of the close/reopen logic.</li>
  <li>By changing the <code class="highlighter-rouge">nonce</code> we effectively close the old channel <code class="highlighter-rouge">[MPEContractAddress, channelId, oldNonce]</code> and open the new one <code class="highlighter-rouge">[MPEContractAddress, channelId, newNonce]</code>. We will go more into details about this later.</li>
  <li><code class="highlighter-rouge">nonce</code> also prevents a race condition between between <code class="highlighter-rouge">channelClaim</code> and <code class="highlighter-rouge">channelExtendAndAddFunds</code>.</li>
  <li>The full ID of the recipient is <code class="highlighter-rouge">[recipient_ethereum_address, groupId]</code>. By doing this we allow the service provider to use the same Ethereum wallet for different replicas.</li>
</ul>

<h3 id="functions">Functions</h3>

<h4 id="opening-a-new-atomic-channel">Opening a New Atomic Channel</h4>

<p>The following function opens the new ‚Äúatomic‚Äù channel, assuming that the caller is the sender:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function openChannel(address  recipient, uint256 value, uint256 expiration, bytes32 groupId, address signer)
</code></pre></div></div>

<p>This function simply creates a new <code class="highlighter-rouge">PaymentChannel</code> structure and adds it to the list of channels.</p>

<h4 id="claiming-funds-from-the-channel">Claiming Funds from the Channel</h4>
<p>With the following function, the recipient can claim funds from the channel.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function channelClaim(uint256 channelId, uint256 amount, uint8 v, bytes32 r, bytes32 s, bool isSendback)
</code></pre></div></div>

<p>It should be noted that <code class="highlighter-rouge">v</code>, <code class="highlighter-rouge">r</code>, <code class="highlighter-rouge">s</code> are parts of the signature. The recipent should present the signature for the following message <code class="highlighter-rouge">[MPEContractAdress, channelId, nonce, amount]</code>. It should be noted that <code class="highlighter-rouge">[MPEContractAdress, channel_id, nonce]</code> is the full ID of the ‚Äúatomic‚Äù channel.</p>

<p>The recipient has two possibilities:</p>
<ul>
  <li><code class="highlighter-rouge">(is_sendback==true)</code> - ‚Äúclose‚Äù the channel and send the remainder back to the sender.</li>
  <li><code class="highlighter-rouge">(is_sendback==false)</code> - ‚Äúclose/reopen‚Äù. We transfer the claimed amount to the recipient, but instead of sending the remainder back to the sender we simple change the nonce of the channel. By doing this we close the old atomic channel <code class="highlighter-rouge">[MPEContractAdress, channel_id, old_nonce]</code> and open the new one <code class="highlighter-rouge">[MPEContractAdress, channel_id, new_nonce]</code>.</li>
</ul>

<h4 id="postponing-the-expiration-time-of-the-channel">Postponing the Expiration Time of the Channel</h4>

<p>With the following functions the client can postpone the expiration time of the channel and she/he can add funds to the channel at any time. She/he can also claim all funds from the channel after the expiration time is reached.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function channelExtend(uint256 channel_id, uint256 new_expiration);
function channelAddFunds(uint256 channel_id, uint256 amount);
function channelExtendAndAddFunds(uint256 channel_id, uint256 new_expiration, uint256 amount);
function channelClaimTimeout(uint256 channel_id);
</code></pre></div></div>

<h2 id="use-cases">Use cases</h2>

<h3 id="description-of-a-use-case">Description of a use case</h3>

<ul>
  <li>The client deposits tokens to the Multi-Party Escrow and uses this as a wallet for their AGI tokens.</li>
  <li>The client selects an AI service provider.</li>
  <li>The client opens a Payment Channel with the chosen payment group.</li>
  <li>It should be noted that the client can send requests to any replica from the selected payment group (replicas in one payment group should share the state of the payment channel amongst others in the payment group)</li>
  <li>The client starts to send requests to the replicas. With each call it sends the signed authorization for the server to ‚Äúwithdraw‚Äù the total amount of AGI tokens which are due.</li>
  <li>At some point, the server can decide to close/reopen channel in order to claim the AGI tokens due. At the next call from the client, the server should inform the client that the <code class="highlighter-rouge">nonce</code> of the channel has been changed (see <a href="/docs/concepts/mpe-stateless-client">this topic on stateless clients</a>).</li>
  <li>At some point, the client can decide to postpone the expiration of the channel or to escrow more funds.</li>
  <li>It should be noted that because of the possibility to repeatedly postpone the expiration of the channel and/or to escrow more funds, the payment channel can exist forever.</li>
</ul>

<h3 id="formal-example-of-the-use-case">Formal example of the use case</h3>

<p>Let‚Äôs assume that one call requires 1 AGI. We also assume that the server and the client perform all required validations on each call. This means it at least checks:</p>
<ul>
  <li>whether the signature is authentic;</li>
  <li>whether the amount of AGI tokens is correct;</li>
  <li>whether this amount does not exceed the value of the channel; and</li>
  <li>whether the expiration date is tolerable.</li>
</ul>

<p><strong>We assume that</strong> <code class="highlighter-rouge">REPLICA1</code> <strong>is from the payment group identified with</strong> <code class="highlighter-rouge">groupId=group1</code>.</p>

<ul>
  <li><code class="highlighter-rouge">CLIENT1</code> initiates a call: <code class="highlighter-rouge">openChannel(recipient=SERVER1, value=10 AGI, expiration=expiration0, groupId=group1, signer=CLIENT1)</code></li>
  <li>Multi-Party Escrow creates the Payment Channel: <code class="highlighter-rouge">[channel_id = 0, sender=CLIENT1, recipient=SERVER1, groupId=group1, value=10 AGI, nonce=0, expiration=expiration0, signer=CLIENT1]</code></li>
  <li>Multi-Party Escrow subtracts <code class="highlighter-rouge">10 AGI</code> from the balance of <code class="highlighter-rouge">CLIENT1</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=0, amount=1)</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=0, amount=2)</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=0, amount=3)</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=0, amount=4)</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=0, amount=5)</code></li>
  <li>Server decides to close/reopen the channel (and claims <code class="highlighter-rouge">5 AGI</code> that is due)</li>
  <li><code class="highlighter-rouge">SERVER1</code> initiates a call: <code class="highlighter-rouge">channelClaim(channel_id = 0, amount=5, signature = SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=0, amount=5), is_sendback=false)</code></li>
  <li>The Multi-Party Escrow adds <code class="highlighter-rouge">5 AGI</code> to the balance of <code class="highlighter-rouge">SERVER1</code></li>
  <li>The Multi-Party Escrow changes the nonce (<code class="highlighter-rouge">nonce +=1</code>) and value (<code class="highlighter-rouge">value -= 5</code>) in the Payment Channel: <code class="highlighter-rouge">[channel_id = 0, sender=CLIENT1, recipient=SERVER1, replicaId=REPLICA1, value=5 AGI, nonce=1, expiration=expiration0]</code></li>
  <li>The client is notified that the channel has been reopened, and that the <code class="highlighter-rouge">nonce</code> has been changed (see <a href="/docs/concepts/mpe-stateless-client">this topic on stateless clients</a>).</li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=1, amount=1)</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=1, amount=2)</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=1, amount=3)</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=1, amount=4)</code></li>
  <li>The client decides to deposit more AGI tokens in the channel and postpones its expiration date.</li>
  <li><code class="highlighter-rouge">CLIENT1</code> calls <code class="highlighter-rouge">channelExtendAndAddFunds(channel_id=0, new_expiration = now + 1day, amount=10 AGI)</code></li>
  <li>The Multi-Party Escrow changes the value and expiration date in the Payment Channel: <code class="highlighter-rouge">[channel_id = 0, sender=CLIENT1, recipient=SERVER1, groupId=group1, value=15 AGI, nonce=1, expiration=expiration1, signer=CLIENT1]</code></li>
  <li>The Multi-Party Escrow subtracts <code class="highlighter-rouge">10 AGI</code> from the balance of <code class="highlighter-rouge">CLIENT1</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=1, amount=5)</code></li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=1, amount=6)</code></li>
  <li>‚Ä¶..</li>
  <li><code class="highlighter-rouge">CLIENT1</code> sends to <code class="highlighter-rouge">SERVER1/REPLICA1</code> the authorization <code class="highlighter-rouge">SIGNED_BY_CLIENT1(ContractAdress=MPEAdress, channel_id=0, nonce=1, amount=10)</code></li>
  <li>The server decides to close/reopen the channel (claims 10 AGI that is due).</li>
  <li>‚Ä¶..</li>
  <li>Client decides to put more AGI tokens in the channel and postpones its expiration date.</li>
  <li>‚Ä¶.</li>
  <li>Server decides to close/reopen the channel.</li>
  <li>‚Ä¶.</li>
  <li>This can be repeated forever.</li>
  <li>‚Ä¶.</li>
  <li>If the server decides to stop working with this client he could close the channel with <code class="highlighter-rouge">channelClaim(...., is_sendback=true)</code></li>
  <li>If the server fails to claim the tokens before timeout (for example if he goes offline forever), then the client can claim all remaining tokens after the expiration date.</li>
</ul>

<h2 id="remarks">Remarks</h2>

<ul>
  <li>The service provider can use the same Ethereum address for all payment groups or she/he can use a different address. In any case, the daemons very rarely need to send an on-chain transaction. This means that we actually don‚Äôt need to provide the daemons with direct access to the private key. Instead, a centralized server could sign the transactions from the daemons (in some cases it even can be done in semi-manual manner by the service owner). We call such a server a treasurer server.</li>
  <li>In the current implementation, the client signs off-chain authorization messages with the signer‚Äôs private key. This means that the client doesn‚Äôt necessarily need to sign transactions with his Ethereum identity. Instead, he can use other key pairs.</li>
  <li>The server does not need to wait for a confirmation from the blockchain after it sends on-chain requests to close/reopen channels (<code class="highlighter-rouge">channelClaim</code>). It can inform the client that the <code class="highlighter-rouge">nonce</code> of the channel has changed, and it can start accepting calls from the client with a new <code class="highlighter-rouge">nonce</code>. It can be shown that it is secure for both the client and the server if the transaction is accepted by the blockchain before the expiration date of the channel. Similarly, the client doesn‚Äôt need to wait for a confirmation from the blockchain after sending the <code class="highlighter-rouge">channelExtendAndAddFunds</code> call. It makes the Multi-Party Escrow functional, even on a very slow Ethereum network.</li>
  <li>The <code class="highlighter-rouge">nonce</code> in the channel prevents a race between the <code class="highlighter-rouge">channelExtendAndAddFunds</code> and <code class="highlighter-rouge">channelClaim</code>. If the client sends the <code class="highlighter-rouge">channelExtendAndAddFunds</code> request and at the same time the
server sends a <code class="highlighter-rouge">channelClaim</code> request, they can continue to work without receiving confirmation from the blockchain. In this case it also does not matter which request will be accepted first (as <code class="highlighter-rouge">channelClaim</code> can only change the <code class="highlighter-rouge">nonce</code>, and cannot create a new Payment Channel structure).</li>
</ul>
:ET